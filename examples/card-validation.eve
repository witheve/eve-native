# Credit Card Validation

commit
  [#credit-card number: "438857601841070"]
end

## Rules for Valid cards

- Be between 13 and 16 digits

- Must start with:
- 4 for Visa cards
- 5 for Master cards
- 37 for American Express cards
- 6 for Discover cards

- Each number goes through a transformation, then is checked whether or not the
  result is divisible by 10. If divisible, then the number is valid. If not, 
  then it is not.
- The transformation can be described below:
  1. Double every second digit from right to left. If doubling of a digit results
     in a two-digit number, add up the two digits to get a single-digit number.
  2. Now add all single-digit numbers from Step 1.
  3. Add all digits in the odd places from right to left in the card number
  4. Sum the results from Step 2 and Step 3.
  5. The result is the number transformed

## Identify Bank

search
  cc = [#credit-card number]
  first-digits = string/substring[text: number from: 1 to: 3]
bind
  cc.first-digits += first-digits
end

search
  cc = [#credit-card first-digits]
  bank = if "4" = string/substring[text: first-digits from: 1 to: 2] then "Visa"
         if "5" = string/substring[text: first-digits from: 1 to: 2] then "Mastercard"
         if "37" = first-digits then "American Express"
         if "6" = string/substring[text: first-digits from: 1 to: 2] then "Discover"
bind
  cc.bank += bank
end

## Transform the cc number

Index every digit in each number

search
  cc = [#credit-card number]
  (token,index) = string/split[text: number by: ""]
  index - 1 > 0
  index - 1 < 17
  numerical-digit = eve/parse-value[value: token]
bind
  [#digits cc index: index - 1 digit: numerical-digit]
end

search
  digits = [#digits cc index digit]
  number-length = string/length[text: cc.number]
  reverse-index = -1 * (index - number-length) + 1
bind

  digits.reverse-index += reverse-index
end

### Step 1. 

Double every second digit from the right. We'll tag these digits as `#even-index`

search
  digits = [#digits cc reverse-index digit]
  0 = math/mod[value: reverse-index, by: 2]
bind
  digits += #even-index
end

If a doubled digit is >= 10, sum the digits of that doubled digit. Othewise 
just double the digit

search
  digi = [#digits #even-index]
  doubled = if digi.digit < 5 then digi.digit * 2
            else if digi.digit = 5 then 1
            else if digi.digit = 6 then 3
            else if digi.digit = 7 then 5
            else if digi.digit = 8 then 7
            else if digi.digit = 9 then 9
bind
  digi.doubled += doubled
end

### Step 2

Sum all of the doubled digits in Step 1 together

search
  digi = [#digits #even-index cc reverse-index doubled]
  doubled-sum = gather/sum[value: doubled for: (doubled,reverse-index) per: cc]
bind
  cc.step-two-sum += doubled-sum
end

### Step 3

Sum the odd digits starting from the right

search
  digits = [#digits cc reverse-index]
  1 = math/mod[value: reverse-index, by: 2]
bind
  digits += #odd-index
end

search
  digits = [#digits #odd-index cc reverse-index]
  step-three-sum = gather/sum[value: digits.digit for: reverse-index per: cc]
bind
  cc.step-three-sum += step-three-sum
end

### Step 4

Sum the results from step 2 and 3

search
  cc = [#credit-card step-two-sum step-three-sum]
  transformed-number = step-two-sum + step-three-sum
bind
  cc.transformed-number += transformed-number
end

## Test Validity

A number is valid if it is between 13 and 16 digits and the transformation
is divisible by 10

search
  cc = [#credit-card number transformed-number]
  number-length = string/length[text: number]
  number-length >= 13
  number-length <= 16
  0 = math/mod[value: transformed-number by: 10]
bind
  cc += #valid
end


## Some Output for Testing

search
  digi = [#digits cc index reverse-index digit]
  doubled = if digi.doubled then digi.doubled
            else ""
  valid = if cc = [#valid] then "valid"
          else "invalid"
bind
  [#html/div #container cc | children: 
    [#html/div sort: -1 text: cc.number]
    [#html/div sort: -2 text: cc.bank]
    [#html/div sort: -2 text: valid]]
end



